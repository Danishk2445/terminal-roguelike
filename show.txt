import curses
import random
import time
import math

# Game Constants
MAP_WIDTH = 40
MAP_HEIGHT = 20
NUM_ENEMIES = 10
WALL_DENSITY = 20
PLAYER_CHAR = '@'
ENEMY_CHAR = 'E'
WALL_CHAR = '#'
FLOOR_CHAR = '.'
ARROW_CHAR = '*'
ENEMY_ARROW_CHAR = '+'  # Distinguish enemy projectiles

# Color pair numbers
PLAYER_COLOR = 1
ENEMY_COLOR = 2
WALL_COLOR = 3
FLOOR_COLOR = 4
PROJECTILE_COLOR = 5
ENEMY_PROJECTILE_COLOR = 6
STATUS_COLOR = 7
WIN_COLOR = 8

class Entity:
    def __init__(self, x, y, char):
        self.x = x
        self.y = y
        self.char = char

class Player(Entity):
    def __init__(self, x, y):
        super().__init__(x, y, PLAYER_CHAR)
        self.health = 100
        self.speed = 1
        self.ammo = 10  # Starting ammo

class Enemy(Entity):
    def __init__(self, x, y):
        super().__init__(x, y, ENEMY_CHAR)
        self.health = 50
        self.speed = 0.5
        self.last_shot_time = time.time()
        self.shoot_delay = random.uniform(1, 3)  # Randomize shooting interval

class Projectile(Entity):
    def __init__(self, x, y, dx, dy, is_enemy=False):
        char = ENEMY_ARROW_CHAR if is_enemy else ARROW_CHAR
        super().__init__(x, y, char)
        self.dx = dx
        self.dy = dy
        self.speed = 2
        self.is_enemy = is_enemy

class Game:
    def __init__(self, stdscr):
        self.stdscr = stdscr
        self.setup_colors()
        curses.curs_set(0)
        stdscr.nodelay(True)
        stdscr.keypad(True)
        self.width = MAP_WIDTH
        self.height = MAP_HEIGHT
        
        # Initialize game state
        self.map = self.generate_map()
        self.player = self.spawn_entity(Player)
        self.enemies = [self.spawn_entity(Enemy) for _ in range(NUM_ENEMIES)]
        self.projectiles = []
        
        self.last_update = time.time()
        self.game_over = False
    
    
    def generate_map(self):
        """Generate a map with walls and floor"""
        map_grid = [[FLOOR_CHAR for _ in range(self.width)] for _ in range(self.height)]
        
        # Create border walls
        for x in range(self.width):
            map_grid[0][x] = WALL_CHAR
            map_grid[self.height-1][x] = WALL_CHAR
        
        for y in range(self.height):
            map_grid[y][0] = WALL_CHAR
            map_grid[y][self.width-1] = WALL_CHAR
        
        # Add some random walls
        for _ in range(self.width * self.height // WALL_DENSITY):
            x, y = random.randint(1, self.width-2), random.randint(1, self.height-2)
            map_grid[y][x] = WALL_CHAR
        
        return map_grid

    def spawn_entity(self, entity_class):
        """Spawn an entity in a random floor tile"""
        while True:
            x, y = random.randint(1, self.width-2), random.randint(1, self.height-2)
            if self.map[y][x] == FLOOR_CHAR:
                return entity_class(x, y)

    def move_entity(self, entity, dx, dy):
        """Move an entity if the destination is a floor tile"""
        new_x, new_y = entity.x + dx, entity.y + dy
        if 0 <= new_x < self.width and 0 <= new_y < self.height:
            if self.map[new_y][new_x] == FLOOR_CHAR:
                entity.x, entity.y = new_x, new_y

    def handle_input(self):
        """Handle player input"""
        key = self.stdscr.getch()
        
            # Movement with arrow keys
        if key == curses.KEY_UP:
            self.move_entity(self.player, 0, -1)
        elif key == curses.KEY_DOWN:
            self.move_entity(self.player, 0, 1)
        elif key == curses.KEY_LEFT:
            self.move_entity(self.player, -1, 0)
        elif key == curses.KEY_RIGHT:
            self.move_entity(self.player, 1, 0)
        
        # Shooting with WASD and additional keys for diagonals
        elif key == ord('w'):  # Up
            self.shoot(self.player.x, self.player.y, 0, -1)
        elif key == ord('s'):  # Down
            self.shoot(self.player.x, self.player.y, 0, 1)
        elif key == ord('a'):  # Left
            self.shoot(self.player.x, self.player.y, -1, 0)
        elif key == ord('d'):  # Right
            self.shoot(self.player.x, self.player.y, 1, 0)
        elif key == ord('q'):  # Up-Left
            self.shoot(self.player.x, self.player.y, -1, -1)
        elif key == ord('e'):  # Up-Right
            self.shoot(self.player.x, self.player.y, 1, -1)
        elif key == ord('z'):  # Down-Left
            self.shoot(self.player.x, self.player.y, -1, 1)
        elif key == ord('c'):  # Down-Right
            self.shoot(self.player.x, self.player.y, 1, 1)
        
        # Quit
        elif key == ord('x'):
            self.game_over = True

    def shoot(self, x, y, dx, dy, is_enemy=False):
        """Create a projectile from a given position"""
        # Only allow player to shoot if they have ammo
        if not is_enemy:
            if self.player.ammo <= 0:
                return  # Cannot shoot if no ammo
            self.player.ammo -= 1  # Consume a bullet
        projectile = Projectile(x, y, dx, dy, is_enemy)
        self.projectiles.append(projectile)

    def update_enemies(self, delta_time):
        """Refined enemy movement and shooting logic"""
        current_time = time.time()
        for enemy in self.enemies:
            # Direct movement towards player with some randomness
            dx = self.player.x - enemy.x
            dy = self.player.y - enemy.y
            
            # Normalize direction
            distance = math.sqrt(dx**2 + dy**2)
            if distance > 0:
                dx = dx / distance
                dy = dy / distance
            
            # Add slight randomness to movement
            dx += random.uniform(-0.2, 0.2)
            dy += random.uniform(-0.2, 0.2)
            
            # Move the enemy
            new_x = enemy.x + dx * enemy.speed * delta_time
            new_y = enemy.y + dy * enemy.speed * delta_time
            
            # Check if the new position is a valid floor tile
            if (0 <= int(new_x) < self.width and 
                0 <= int(new_y) < self.height and 
                self.map[int(new_y)][int(new_x)] == FLOOR_CHAR):
                enemy.x = new_x
                enemy.y = new_y
            
            # Enemy shooting logic
            if current_time - enemy.last_shot_time >= enemy.shoot_delay:
                # Calculate direction to player
                shot_dx = self.player.x - enemy.x
                shot_dy = self.player.y - enemy.y
                
                # Normalize direction
                shot_distance = math.sqrt(shot_dx**2 + shot_dy**2)
                if shot_distance > 0:
                    shot_dx /= shot_distance
                    shot_dy /= shot_distance
                
                # Shoot towards the player
                self.shoot(enemy.x, enemy.y, shot_dx, shot_dy, is_enemy=True)
                
                # Reset shot timer and randomize delay
                enemy.last_shot_time = current_time
                enemy.shoot_delay = random.uniform(1, 3)

    def update_projectiles(self, delta_time):
        """Update projectile positions and check for collisions"""
        for projectile in self.projectiles[:]:
            # Move projectile based on its direction and speed
            projectile.x += projectile.dx * projectile.speed * delta_time
            projectile.y += projectile.dy * projectile.speed * delta_time
            
            # Check map bounds
            if (projectile.x < 0 or projectile.x >= self.width or 
                projectile.y < 0 or projectile.y >= self.height):
                self.projectiles.remove(projectile)
                continue
            
            # Check wall collision
            if self.map[int(projectile.y)][int(projectile.x)] == WALL_CHAR:
                self.projectiles.remove(projectile)
                continue
            
            # Check player collision for enemy projectiles
            if projectile.is_enemy:
                if (math.floor(self.player.x) == math.floor(projectile.x) and 
                    math.floor(self.player.y) == math.floor(projectile.y)):
                    # Implement player damage or game over
                    self.player.health -= 10
                    self.projectiles.remove(projectile)
                    if self.player.health <= 0:
                        self.game_over = True
                    continue
            
            # Check enemy collision for player projectiles
            else:
                for enemy in self.enemies[:]:
                    if (math.floor(enemy.x) == math.floor(projectile.x) and 
                        math.floor(enemy.y) == math.floor(projectile.y)):
                        self.projectiles.remove(projectile)
                        self.enemies.remove(enemy)
                        # add 2 ammo when killing an enemy
                        self.player.ammo += 2
                        break
    
    def setup_colors(self):
        """Initialize color pairs"""
        # Start curses color functionality
        curses.start_color()
        curses.use_default_colors()

        # Initialize color pairs
        curses.init_pair(PLAYER_COLOR, curses.COLOR_GREEN, -1)
        curses.init_pair(ENEMY_COLOR, curses.COLOR_RED, -1)
        curses.init_pair(WALL_COLOR, curses.COLOR_WHITE, curses.COLOR_WHITE)
        curses.init_pair(FLOOR_COLOR, curses.COLOR_BLACK, -1)
        curses.init_pair(PROJECTILE_COLOR, curses.COLOR_YELLOW, -1)
        curses.init_pair(ENEMY_PROJECTILE_COLOR, curses.COLOR_MAGENTA, -1)
        curses.init_pair(STATUS_COLOR, curses.COLOR_CYAN, -1)
        curses.init_pair(WIN_COLOR, curses.COLOR_GREEN, -1)
        
    def render(self):
        """Render the game state with colors"""
        self.stdscr.clear()
        
        # Render map
        for y in range(self.height):
            for x in range(self.width):
                char = self.map[y][x]
                if char == WALL_CHAR:
                    self.stdscr.addch(y, x, char, curses.color_pair(WALL_COLOR))
                else:
                    self.stdscr.addch(y, x, char, curses.color_pair(FLOOR_COLOR))
        
        # Render player
        self.stdscr.addch(self.player.y, self.player.x, 
                         self.player.char, 
                         curses.color_pair(PLAYER_COLOR) | curses.A_BOLD)
        
        # Render enemies
        for enemy in self.enemies:
            self.stdscr.addch(int(enemy.y), int(enemy.x), 
                            enemy.char, 
                            curses.color_pair(ENEMY_COLOR) | curses.A_BOLD)
        
        # Render projectiles
        for projectile in self.projectiles:
            color = ENEMY_PROJECTILE_COLOR if projectile.is_enemy else PROJECTILE_COLOR
            self.stdscr.addch(int(projectile.y), int(projectile.x), 
                            projectile.char, 
                            curses.color_pair(color) | curses.A_BOLD)
        
        # Render game stats with color
        status = f"Enemies Left: {len(self.enemies)} | Health: {self.player.health} | Ammo: {self.player.ammo}"
        self.stdscr.addstr(self.height, 0, status, 
                          curses.color_pair(STATUS_COLOR) | curses.A_BOLD)
        
        self.stdscr.refresh()

    def run(self):
        """Main game loop"""
        while not self.game_over:
            # Calculate delta time
            current_time = time.time()
            delta_time = current_time - self.last_update
            self.last_update = current_time
            
            # Handle input
            self.handle_input()
            
            # Update game state
            self.update_projectiles(delta_time)
            self.update_enemies(delta_time)
            
            # Render game
            self.render()
            
            # Check win conditions
            if not self.enemies:
                # Clear the screen
                self.stdscr.clear()
                
                # Get screen dimensions
                max_y, max_x = self.stdscr.getmaxyx()
                
                # Calculate center of screen for messages
                win_message = "You Win!"
                play_again_message = "Press 'y' to play again or 'q' to quit"
                
                win_y = max_y // 2 - 1
                play_again_y = max_y // 2 + 1
                win_x = (max_x - len(win_message)) // 2
                play_again_x = (max_x - len(play_again_message)) // 2
                
                # Add win and play again messages
                self.stdscr.addstr(win_y, win_x, win_message, 
                                 curses.color_pair(WIN_COLOR) | curses.A_BOLD)
                self.stdscr.addstr(play_again_y, play_again_x, play_again_message, 
                                 curses.color_pair(STATUS_COLOR))
                self.stdscr.refresh()
                
                # Wait for play again decision
                while True:
                    key = self.stdscr.getch()
                    if key == ord('y'):
                        # Reset the game
                        self.__init__(self.stdscr)
                        break
                    elif key == ord('q'):
                        self.game_over = True
                        break
            
            # Small delay to control game speed
            time.sleep(0.05)

    def __init__(self, stdscr):
        """Initialize or reset game state"""
        self.stdscr = stdscr
        curses.curs_set(0)
        stdscr.nodelay(True)
        stdscr.keypad(True)  # Ensure keypad is enabled
        self.width = MAP_WIDTH
        self.height = MAP_HEIGHT
        
        # Initialize game state
        self.map = self.generate_map()
        self.player = self.spawn_entity(Player)
        self.enemies = [self.spawn_entity(Enemy) for _ in range(NUM_ENEMIES)]
        self.projectiles = []
        
        self.last_update = time.time()
        self.game_over = False

def main(stdscr):
    game = Game(stdscr)
    game.run()

if __name__ == "__main__":
    curses.wrapper(main)